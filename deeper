#!/usr/bin/env python3

import sys
import time
import arg_parse_deeper
import exceptor
import os
import random
import subprocess
import termcolor
from concurrent import futures
from typing import List


class Deeper:

    def __init__(self):
        self.args = arg_parse_deeper.Argparse_Deeper()
        self.argparse = self.args.get_args()
        self.port = self.args.port
        self.top_ten_list = ["21","22","23","25","80","110","139","143","443","445","3389"]


    def get_top_ports_list(self, protocol: str) -> List:
        try:
            if "tcp" in protocol:
                path = os.getcwd() + "/tcp_ports_1000.txt"
            elif "udp" in protocol:
                path = os.getcwd() + "/udp_ports_1000.txt"
            else:
                raise Exception
            with open(path, "r") as file:
                ports = file.readlines()
                ports = [p.rstrip("\n") for p in ports]
            if not self.args.no_random:
                random.shuffle(ports)
            return ports
        except Exception as e:
            exceptor.Exceptor().catchit("get_top_ports_list", str(e))


    def get_ports(self) -> List:
        try:
            ports = [str(i) for i in range(int(self.args.min), int(self.args.max)+1)]
            if not self.args.no_random:
                random.shuffle(ports)
            return ports
        except Exception as e:
            exceptor.Exceptor().catchit("get_ports", str(e))


    def build_mask_addresses(self, ip: str, mask: str) -> List:
         try:
            oct1, oct2, oct3, oct4 = ip.split(".")
            third_octets = [int(oct3) + i for i in range(0, 255)]
            addresses = []
            for third in third_octets:
                if third > 255:
                    raise AssertionError
                ips = [str(oct1) + "." + str(oct2) + "." + str(third) + "." +
                       str(i) for i in range(0, 255)]
                addresses = addresses + ips
                if mask == "24":
                    if third == int(oct3):
                        return addresses
                if mask == "23":
                    if third == int(oct3) + 1:
                        return addresses
                if mask == "22":
                    if third == int(oct3) + 3:
                        return addresses
                if mask == "21":
                    if third == int(oct3) + 7:
                        return addresses
                if mask == "20":
                    if third == int(oct3) + 15:
                        return addresses
                if mask == "16":
                    if third == int(oct3) + 254:
                        return addresses
         except AssertionError as a:
             exceptor.Exceptor().catchit("build_mask_addresses: Third Octet exceeded 255.", str(a))
         except Exception as e:
             exceptor.Exceptor().catchit("build_mask_addresses", str(e))


    def get_mask_addresses(self, ip: str, mask: str) -> List:
        try:
            if (int(mask) > 19 and int(mask) < 24
                    or int(mask) == 16
                    or int(mask) == 24):
                addresses = self.build_mask_addresses(ip, mask)
                return addresses
            else:
                print("\n Sorry... only /16 /20 /21 /22 /23 and /24 networks are permitted.\n")
                exit(1)
        except Exception as e:
            exceptor.Exceptor().catchit("get_mask_addresses", str(e))


    def ip_cmd(self, ip: str):
        try:
            cmd = (self.args.command + str(ip) + " " + self.args.scan_type + " -p " +
                   self.port + " >> " + self.args.logfile)
            print(cmd)
            subprocess.run([cmd], shell=True)
        except Exception as e:
            exceptor.Exceptor().catchit("ip_cmd", str(e))


    def ip_cmd_runner(self, addresses: List):
        try:
            with futures.ProcessPoolExecutor(self.args.procs) as pool:
                pool.map(self.ip_cmd, addresses)
        except Exception as e:
            exceptor.Exceptor().catchit("ip_cmd_runner", str(e))


    def ip_controller(self):
        try:
            net, mask = self.args.target.split("/")
            addresses = self.get_mask_addresses(str(net), str(mask))
            self.ip_cmd_runner(addresses)
        except Exception as e:
            exceptor.Exceptor().catchit("ip_controller", str(e))


    def command_runner(self, port: str):
        try:
            print(port)
            cmd = (self.args.command + self.args.target + " " + self.args.scan_type +
                   " -p " + port + " >> " + self.args.logfile)
            print(cmd)
            subprocess.run([cmd], shell=True)
        except Exception as e:
            exceptor.Exceptor().catchit("command_runner", str(e))


    def controller(self, ports: List):
        try:
            with futures.ProcessPoolExecutor(self.args.procs) as pool:
                pool.map(self.command_runner, ports)
        except Exception as e:
            exceptor.Exceptor().catchit("controller", str(e))


    def port_controller(self) -> List:
        try:
            if self.args.top_tcp:
                ports = self.get_top_ports_list("tcp")
            elif self.args.top_udp:
                ports = self.get_top_ports_list("udp")
            elif self.args.port:
                ports = [self.args.port]
            elif self.args.port_list:
                ports = [p for p in self.args.port_list for p in p]
            elif self.args.top_ten:
                ports = self.top_ten_list
            elif self.args.port:
                ports = [self.args.port]
            else:
                ports = self.get_ports()
            return ports
        except Exception as e:
            exceptor.Exceptor().catchit("port_controller", str(e))


    def banner(self):
        try:
            os.system("clear")
            color = "blue"
            print(termcolor.colored("***************************************************************************", color))
            print(termcolor.colored("*  ________ ", color))
            print(termcolor.colored("*  ___  __ \_____ _____ ________ _____ ________", color))
            print(termcolor.colored("*  __  / / /_  _ \_  _ \___  __ \_  _ \__  ___/", color))
            print(termcolor.colored("*  _  /_/ / /  __//  __/__  /_/ //  __/_  /    ", color))
            print(termcolor.colored("*  /_____/  \___/ \___/ _  .___/ \___/ /_/", color))
            print(termcolor.colored("*                       /_/     ", color))
            print(termcolor.colored("*\n* Know thy self, know thy enemy. A thousand battles, a thousand victories.", color))
            print(termcolor.colored("***************************************************************************", color))
        except Exception as e:
            exceptor.Exceptor().catchit("banner", str(e))


    def display_results(self):
        try:
            t1 = time.perf_counter()
            with open(self.args.logfile, "r") as file:
                logs = file.readlines()
                if not logs:
                    print("log file empty.")
                    raise Exception
                down = [l for l  in logs if "host down" in l]
                [print("Host appears down: " + d) for d in down]
                ports = [l for l in logs if "tcp" in l or "udp" in l]
                if not ports:
                    print("Host/s seem to be down..")
                    print("logs file empty.")
                    raise Exception
                ports = [l for l in logs if "tcp" in l or "udp" in l]
                if not ports:
                    raise Exception
                [print(p.rstrip("\n")) for p in ports]
                closed = [p for p in ports if "closed" in p]
                filter = [p for p in ports if "filter" in p]
                open_ports = [p for p in ports if "Discovered open" in p
                              and not "closed" in p and not "filter" in p]
                total = len(ports)
                num_cl = len(closed)
                num_fl = len(filter)
                num_op = len(open_ports)
                total = total - num_op
                print("\n******************************************************\n"
                      "Total Ports Scanned: " + str(total))
                print("Closed: " + str(num_cl))
                print("Filtered: " + str(num_fl))
                print("Open: " + str(num_op))
                if num_op > 0:
                    print("\n********** Open Ports **********")
                    [print(o.rstrip()) for o in open_ports]
                    print("*********************************")
                else:
                    print("\nNo ports discovered open. :(")
            t2 = time.perf_counter()
            print("\nTime to calculate and display results: " + str(round(t2-t1, 4)) + "sec\n")
        except Exception as e:
            exceptor.Exceptor().catchit("display_results", str(e))


def check_python_version():
    try:
        x, y, z, a, b = sys.version_info
        ver = str(x) + str(y)
        if int(ver) < 36:
            print("\nThis application requires Python 3.6 or greater.\nhttps://www.python.org/downloads/\n")
            exit(1)
    except Exception as e:
        exceptor.Exceptor().catchit("check_python_version", e)


#TODO: -p switch comma sep
if __name__ == '__main__':
    try:
        check_python_version()
        t1 = time.perf_counter()
        new_Nmap = Deeper()
        new_Nmap.banner()
        print("\nWARNING! This program intentionally utalises system resources for performance.\n"
              "Your system may become temporarily unresponsive.\n\nProcessing..")
        ports = new_Nmap.port_controller()
        if new_Nmap.args.ip_splitting:
            for p in ports:
                new_Nmap.port = str(p)
                new_Nmap.ip_controller()
        else:
            new_Nmap.controller(ports)
        print("Calculating results..")
        new_Nmap.display_results()
        t2 = time.perf_counter()
        print("\nTotal Execution Time: " + str(round(t2 - t1, 4)) + "sec\n")
        os.system("stty sane")
    except Exception as e:
        exceptor.Exceptor().catchit("main()", e)

