#!/usr/bin/env python3

import argparse
import os
import sys
import time
import subprocess
import datetime
import random
import termcolor
from concurrent import futures


class Deeper:

    def __init__(self):
        try:
            self.top_udp = False
            self.top_tcp = False
            self.ports = False
            self.no_random = False
            self.ip_splitting = False
            self.command = ""
            self.target = ""
            self.scan_type = ""
            self.min = ""
            self.max = ""
            self.port = ""
            self.logfile = ""
            self.timestamp = datetime.datetime.now().strftime("%Y_%m_%d_%H_%M_%S")
            self.port_cnt: int = 0
            self.procs: int = 0

        except Exception as e:
            print("Error! in __init__: " + str(e))


    def get_args(self) -> argparse:
        try:
            args = argparse.ArgumentParser()
            args.add_argument("target", help="Network or host to scan", type=str)
            args.add_argument("--udp", "-sU", help="UDP Scan, default -sS syn", action='store_true')
            args.add_argument("--tcp", "-sT", help="TCP Scan, default -sS syn", action='store_true')
            args.add_argument("--ip", "-i", help="Spawn processes per IP, rather than by port. "
                                                 "Use when scanning a larger network for a single port.", action="store_true")
            args.add_argument("--ver", "-sV", help="Determine service/version info", action='store_true')
            args.add_argument("--time", "-T", help="nmap time profile T1-5, default -T2")
            args.add_argument("--ports", "-p", help="Port range eg. \"80-443\"", type=str)
            args.add_argument("--no_random", "-r", help="Port range will not be randomised", action='store_true')
            args.add_argument("--procs", "-z", help="Number of processes to spawn, 1-999, default 256", type=int)
            parsed = args.parse_args()

            self.target = parsed.target
            if "/" in self.target:
                log_target = str(self.target).replace("/", "_")
            else:
                log_target = self.target

            self.logfile = os.getcwd() + "/deeper_" + log_target + "_" + self.timestamp + ".log"
            self.no_random = parsed.no_random
            if parsed.procs:
                if parsed.procs > 0 and parsed.procs < 1000:
                    self.procs = parsed.procs
                else:
                    print("Processes must be less than 1000 due to OS limitations.")
                    exit(1)
            else:
                self.procs = 256

            if parsed.time:
                self.command = "nmap -Pn -v -T" + str(parsed.time) + " "
            else:
                self.command = "nmap -T2 -Pn -v "

            if parsed.ver:
                self.command = self.command + "-sCV --version-all "

            if parsed.ip:
                self.ip_splitting = parsed.ip

            if not parsed.udp and not parsed.tcp:
                self.scan_type = "-sS"

            if parsed.tcp:
                if not parsed.udp:
                    self.scan_type = "-sT"
                else:
                    print("TCP and UDP scans are mutually exclusive. Please select only one.")
                    exit(1)

            if parsed.udp:
                if not parsed.tcp:
                    self.scan_type = "-sU"
                else:
                    print("TCP and UDP scans are mutually exclusive. Please select only one.")
                    exit(1)

            if parsed.ports:
                if len(parsed.ports) > 50:
                    print("\nPlease specify a range of ports. example: \"1-1024\"")
                    exit(1)
                elif "-" not in parsed.ports:
                    self.port = str(parsed.ports)
                else:
                    pmin, pmax = parsed.ports.split("-")
                    self.min = pmin
                    self.max = pmax
                    self.ports = True

            elif not parsed.ports:
                if parsed.udp:
                    self.top_udp = True
                else:
                    self.top_tcp = True

        except Exception as e:
            print("Error! in get_args: " + str(e))


    def get_top_ports_list(self, protocol):
        try:
            if "tcp" in protocol:
                path = os.getcwd() + "/tcp_ports_1000.txt"
            elif "udp" in protocol:
                path = os.getcwd() + "/udp_ports_1000.txt"
            else:
                raise Exception
            with open(path, "r") as file:
                ports = file.readlines()
                ports = [str(b).rstrip() for b in str(ports).split(",")]
            if not self.no_random:
                random.shuffle(ports)
            return ports
        except Exception as e:
            print("Error in get_top_ports_list: " + str(e))


    def get_ports(self):
        try:
            ports = [str(i) for i in range(int(self.min), int(self.max)+1)]
            if not self.no_random:
                random.shuffle(ports)
            return ports
        except Exception as e:
            print("Error! in get_ports: " + str(e))


    def get_mask_addresses(self, mask: int) -> int:
        try:
            if mask < 24 or mask > 27:
                print("\nPlease use a mask between 24 and 27.")
                exit(1)
            if mask == 27:
                ip_cnt = 32
            elif mask == 26:
                ip_cnt = 64
            elif mask == 25:
                ip_cnt = 127
            elif mask == 24:
                ip_cnt = 255
            else:
                raise Exception
            return ip_cnt
        except Exception as e:
            print("Error in get_mask_addresses: " + str(e))


    def ip_cmd(self, ip):
        cmd = (self.command + str(ip) + " " + self.scan_type + " -p " + self.port + " >> " + self.logfile)
        print(cmd)
        subprocess.run([cmd], shell=True)


    def ip_cmd_runner(self, addresses):
        try:
            with futures.ProcessPoolExecutor(self.procs) as pool:
                pool.map(self.ip_cmd, addresses)
        except Exception as e:
            print("Error in ip_cmd_runner: " + str(e))


    def ip_controller(self):
        try:
            net, mask = self.target.split("/")
            numb_ips = self.get_mask_addresses(int(mask))
            addresses = [str(i) for i in range(0, numb_ips)]
            net = str(net).rstrip("0")
            addresses = [net + a for a in addresses]
            self.ip_cmd_runner(addresses)
        except Exception as e:
            print("Error in ip_controller: " + str(e))


    def command_runner(self, port):
        try:
            cmd = (self.command + self.target + " " + self.scan_type + " -p " + port + " >> " + self.logfile)
            print(cmd)
            subprocess.run([cmd],stdout=subprocess.PIPE, shell=True)
        except Exception as e:
            print("Error in command_runner: " + str(e))


    def controller(self, ports):
        try:
            with futures.ProcessPoolExecutor(self.procs) as pool:
                pool.map(self.command_runner, ports)
        except Exception as e:
            print("Error! in controller: " + str(e))


    def port_controller(self):
        if self.top_tcp:
            ports = self.get_top_ports_list("tcp")
        elif self.top_udp:
            ports = self.get_top_ports_list("udp")
        elif self.port:
            ports = [self.port]
        else:
            ports = self.get_ports()
        return ports


    def banner(self):
        os.system("clear")
        color = "blue"
        print(termcolor.colored("***************************************************************************", color))
        print(termcolor.colored("*  ________ ", color))
        print(termcolor.colored("*  ___  __ \_____ _____ ________ _____ ________", color))
        print(termcolor.colored("*  __  / / /_  _ \_  _ \___  __ \_  _ \__  ___/", color))
        print(termcolor.colored("*  _  /_/ / /  __//  __/__  /_/ //  __/_  /    ", color))
        print(termcolor.colored("*  /_____/  \___/ \___/ _  .___/ \___/ /_/", color))
        print(termcolor.colored("*                       /_/     ", color))
        print(termcolor.colored("*\n* Know thy self, know thy enemy. A thousand battles, a thousand victories.", color))
        print(termcolor.colored("***************************************************************************", color))


    def display_results(self):
        try:
            t1 = time.perf_counter()
            with open(self.logfile, "r") as file:
                logs = file.readlines()
                ports = [l for l in logs if "tcp" in l or "udp" in l]
                [print(p.rstrip("\n")) for p in ports]
                closed = [p for p in ports if "closed" in p]
                filter = [p for p in ports if "filter" in p]
                open_ports = [p for p in ports if "Discovered open" in p
                              and not "closed" in p and not "filter" in p]
                total = len(ports)
                num_cl = len(closed)
                num_fl = len(filter)
                num_op = len(open_ports)
                total = total - num_op
                print("\n******************************************************\n"
                      "Total Ports Scanned: " + str(total))
                print("Closed: " + str(num_cl))
                print("Filtered: " + str(num_fl))
                print("Open: " + str(num_op))
                if num_op > 0:
                    print("\n********** Open Ports **********")
                    [print(o.rstrip()) for o in open_ports]
                    print("*********************************")
                else:
                    print("\nNo ports discovered open. :(")
            t2 = time.perf_counter()
            print("\nTime to calculate and display results: " + str(round(t2-t1, 4)) + "sec\n")
        except Exception as e:
            print("Error! in display_results: " + str(e))


def check_python_version():
    try:
        x, y, z, a, b = sys.version_info
        ver = str(x) + str(y)
        if int(ver) < 36:
            print("\nThis application requires Python 3.6 or greater.\nhttps://www.python.org/downloads/\n")
            exit(1)
    except Exception as e:
        print("Error! in check_python_version: " + str(e))


if __name__ == '__main__':
    try:
        check_python_version()
        t1 = time.perf_counter()
        new_Nmap = Deeper()
        new_Nmap.get_args()
        new_Nmap.banner()
        print("\nWARNING! This program intentionally utalises system resources for performance.\n"
              "Your system may become temporarily unresponsive.\n\nProcessing..")

        ports = new_Nmap.port_controller()
        if new_Nmap.ip_splitting:
            for p in ports:
                new_Nmap.port = str(p)
                new_Nmap.ip_controller()
        else:
            new_Nmap.controller(ports)

        print("Calculating results..")
        new_Nmap.display_results()
        t2 = time.perf_counter()
        print("\nTotal Execution Time: " + str(round(t2 - t1, 4)) + "sec\n")
        os.system("stty sane")

    except Exception as e:
        print("Error! in main(): " + str(e))
